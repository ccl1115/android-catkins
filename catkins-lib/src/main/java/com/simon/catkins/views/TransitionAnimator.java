/*
 * Copyright (c) 2013. All rights reserved by bb.simon.yu@gmail.com
 */

package com.simon.catkins.views;

import android.graphics.Canvas;
import android.view.MotionEvent;

/**
 * Android自定义动画机制
 *
 *    使用android.os.Handler控制动画的帧，并且将对动画的计算和动画的绘制分开。
 *    Handler是Android提供的方便操作Looper（UI循环）的工具类。由于动画的计算
 *    时间远远小于动画的绘制时间，而为了保证动画的速度的均匀，我们需要在固定的时间
 *    内（每1000/60毫秒，即每秒绘制60次）请求一次绘制。这主要是通过Handler来实现的。
 *    
 *    举一个实际的例子，假如我们要进行一个最简单的匀速运动动画：一张图片从屏幕的左边滑动
 *    到屏幕的右边。在这个运动的过程中我们需要一个最简单的算法就是：位移=速度×时间。
 *    动画始终是基于时间的，那么我们就要知道在连续的时间内，每一个时间点的位移。
 *    如果这个动画持续了一秒钟，并且我们需要动画的帧数是60的话。我们需要得到60个位移的
 *    精确值。
 *
 *    在这里有两种情况，一种是边进行绘制边进行计算，一种是计算了所有的结果，在进行绘制。
 *    前者适合简单的运算，显然在上面的这个简单的例子中，边绘制边计算是没有什么问题的。
 *    别说一秒种计算60次，即便是一个变加速的运动，一秒种计算几十万次对于当下的Android手机
 *    都是非常轻松的。当然很多时候我们的动画远远复杂于一个匀速运动，比如我们要计算一场
 *    雨（通常达到这样的计算量，我们称之为模拟），它要达到模拟现实的一场雨的话，计算量
 *    已经不允许我们使用边计算边绘制的方式了。我们需要把这些东西全部都计算出来放到内存中，
 *    然后再进行绘制，而这样往往需要更多的内存来保存这些数据。
 *
 *    更多的时候我们不知道到底需要前者还是后者来计算，我们不能写好了代码再去验证我们的计算
 *    话了多少时间。所以我们需要把计算和绘制在代码级别下分开来。那么接下来的问题就是计算和绘制
 *    之间的同步。绘制是GPU的工作，但是很多情况下我们还是用CPU来做计算。因为我们毕竟不是
 *    写游戏甚至是游戏的引擎。在计算和绘制同时进行的情况下，同步问题就显得非常重要。
 *
 *    比如这个时候我们在运行动画，但是CPU突然被其他的进程使用，导致我们的计算没有办法每1000/60毫秒
 *    计算一次。这个时候我们需要跳帧，否则在等待的过程中我们的动画速度就不可能再是匀速的了。
 *    还有一种情况是，GPU的性能太差，如果你要绘制的东西过于复杂的东西，也就是说绘制不可能在
 *    1000/60毫秒内完成，那么我们也只能跳帧（或者是非实时的渲染，CG动画）。好在在Android系统中，我们不需要接触到绘制的底层，
 *    我们只需要简单的每1000/60毫秒请求一次绘制就可以了。如果上次绘制没有完成，Android系统
 *    会自动的跳过下一次绘制的请求。
 *
 *    当然，除非是做游戏，我们不需要考虑那么多。在大部分Android设备上，对视图做简单的动画
 *    都已经有现成的可行的设计模式。也就是第一段提到的使用Handler，因为它已经对同步处理得很好了，
 *    甚至可以完成跨线程的同步。而对于视图之间的动画，它往往都是一些补间动画。例如从位置A移动
 *    到位置B，从高度100缩小到高度50。唯一的变化可能是有时候是减速运动，有时候有回弹效果等等。
      这个时候，我们可以使用各种算法来替代最简单的匀速运动。但是问题就是如果我们需要临时
 *    的变更一下动画类型，或者是叠加回弹和减速的效果，这种反复替换算法的方式就带来极大的不便利。
 *    在动画技术里，我们还常常使用的技术就是离散数学中的插值。
 *
 *    假设我们在水平坐标系中有一系列离散的点，我们将它们依次的用之间链接起来，如果我们用Y轴表示
 *    动画的位移，那么我们得到的就是位移的匀速变化。如果我们使用一些插值公式，这些点就可以
 *    用曲线链接起来，从而变成非匀速的位移变化。
 *
 *    但是在Android视图动画的实际应用中，我们只有两个点，起始点和结束点，这样的情况可以大大的简化出
 *    一个模型来。我们以0为开始，1为结束，输入线性的变化，然后通过一个插值方程，输出一个从0到1的
 *    非线性变化，至于是什么样的变化，取决于我们实际的需求。这样的设计使得动画的组合变得非常的
 *    简单。
 */
public interface TransitionAnimator {
  void measure(int widthMeasureSpec, int heightMeasureSpec);

  void layout(boolean changed, int l, int t, int r, int b);

  void draw(Canvas canvas);

  boolean dispatchTouchEvent(MotionEvent event);

  boolean interceptionTouchEvent(MotionEvent event);

  boolean touchEvent(MotionEvent event);

  void animate(int msg);

  boolean isAnimating();
}
